/*
	AppDebugMessageHandler
	https://github.com/mpaperno/maxLibQt

	COPYRIGHT: (c)2017 Maxim Paperno; All Right Reserved.
	Contact: http://www.WorldDesign.com/contact

	LICENSE:

	Commercial License Usage
	Licensees holding valid commercial licenses may use this file in
	accordance with the terms contained in a written agreement between
	you and the copyright holder.

	GNU General Public License Usage
	Alternatively, this file may be used under the terms of the GNU
	General Public License as published by the Free Software Foundation,
	either version 3 of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	A copy of the GNU General Public License is available at <http://www.gnu.org/licenses/>.
*/

#ifndef APPDEBUGMESSAGEHANDLER_H
#define APPDEBUGMESSAGEHANDLER_H

#include <QtCore>
#include <QDebug>
#include <QIODevice>
#include <QObject>
#include <QRegularExpression>
#include <QReadWriteLock>

//! Enable/disable this custom handler handler entirely \relates AppDebugMessageHandler
#ifndef APP_DBG_HANDLER_ENABLE
	#define APP_DBG_HANDLER_ENABLE                1
#endif

//! Default log level. \sa AppDebugMessageHandler::appDebugOutputLevel  \relates AppDebugMessageHandler
#ifndef APP_DBG_HANDLER_DEFAULT_LEVEL
	#define APP_DBG_HANDLER_DEFAULT_LEVEL         0
#endif

//! Include source file path/name in output (filtered with APP_DBG_HANDLER_SRC_PATH).
//! \sa AppDebugMessageHandler::showSourcePath  \relates AppDebugMessageHandler
#ifndef APP_DBG_HANDLER_SHOW_SRC_PATH
	#define APP_DBG_HANDLER_SHOW_SRC_PATH         0
#endif

//! Show full function declaration with return and attribute types instead of just the Class::Name.
//! \sa AppDebugMessageHandler::showFunctionDeclarations  \relates AppDebugMessageHandler
#ifndef APP_DBG_HANDLER_SHOW_FUNCTION_DECL
	#define APP_DBG_HANDLER_SHOW_FUNCTION_DECL    0
#endif

//! Include timestamp in default message pattern.  \sa AppDebugMessageHandler::showTimestamp  \relates AppDebugMessageHandler
#ifndef APP_DBG_HANDLER_SHOW_TIMESTAMP
	#define APP_DBG_HANDLER_SHOW_TIMESTAMP        0
#endif

//! Default timestamp format (as per Qt message pattern docs for %{time ...} options).
//! \sa AppDebugMessageHandler::timestampFormat  \relates AppDebugMessageHandler
#ifndef APP_DBG_HANDLER_TIMESTAMP_FORMAT
	#define APP_DBG_HANDLER_TIMESTAMP_FORMAT      "process"
#endif

//! base path for source file name filter, everything after this is kept; RegEx, non-greedy
//! \sa AppDebugMessageHandler::setSourceBasePath()  \relates AppDebugMessageHandler
#ifndef APP_DBG_HANDLER_SRC_PATH
	#define APP_DBG_HANDLER_SRC_PATH              ".*src"
#endif

// Make sure to include this header if using qInfo()
#if (QT_VERSION < QT_VERSION_CHECK(5, 5, 0))
	#if defined(QT_NO_INFO_OUTPUT)
		#define qInfo      QT_NO_QDEBUG_MACRO
	#else
		#define qInfo      qDebug
	#endif
	#define QtInfoMsg    QtMsgType(4)
#endif

/*!
	\class AppDebugMessageHandler
	\version 2.0.0

	\brief Custom debug/message handler class to work in conjunction with \c qDebug() family of functions.

	AppDebugMessageHandler helps with formatting all stderr output generated by the application in a consistent manner.
	For example the function and line from which the debug message is called is always printed.
	It can also be used by other event listeners to intercept messages they may be interested in (connect to \c messageOutput() signal
	or add a \c QIODevice to receive the output).

	You can set a minimum logging level for all messages by setting the \ref appDebugOutputLevel property or \c APP_DBG_HANDLER_DEFAULT_LEVEL macro.

	There are several properties which control the default output message formatting. Optionally, a custom pattern can be set with
	\c setMessagePattern(). This type of custom pattern allows for additional placeholder values which are not available with
	the default Qt handler. See \c setMessagePattern() for details.

	Note that the message format can still be overridden by setting \e QT_MESSAGE_PATTERN environment variable at _run-time_.
		see: https://doc.qt.io/qt-5/qtglobal.html#qSetMessagePattern

	Include this header to use qInfo() safely with Qt < v5.5 (qInfo becomes alias for qDebug).

	This is an app-wide "global" thread-safe singleton class, use it with \c AppDebugMessageHandler::instance().
	For example, at start of application:

	\code
		QApplication app(argc, argv);
		AppDebugMessageHandler::instance()->installAppMessageHandler();
	\endcode

	To connect to a signal:

	\code
		connect(AppDebugMessageHandler::instance(), &AppDebugMessageHandler::messageOutput, this, &DebugOutput::onAppDebugMessage);}
	\endcode

	To add a new I/O stream for receiving messages (eg. a log file):

	\code
		addOutputDevice(myQFile);
	\endcode

	When adding a QIODevice in this way, you may optionally set a minimum severity level below which you do not want messages
	written to this device.  Use the Qt property system to set a properly named \a level on the QIODevice. For example:

	\code
		myQFile.setProperty("level", 2);  // only warning and higher
	\endcode

*/
class AppDebugMessageHandler : public QObject
{
		Q_OBJECT
		//! Minimum severity level of messages to print. 0 = debug+; 1 = info+; 2 = warning+; 3 = critical+; 4 = fatal only. \pacc appDebugOutputLevel(void), setAppDebugOutputLevel()
		Q_PROPERTY(int appDebugOutputLevel READ appDebugOutputLevel WRITE setAppDebugOutputLevel)
		//! Enables or disabled showing the file path in the default message pattern. \pacc showSourcePath(void), setShowSourcePath() \sa setSourceBasePath()
		Q_PROPERTY(bool showSourcePath READ showSourcePath WRITE setShowSourcePath)
		//! Enables or disables showing full function declarations (with return and attribute types) in the default message pattern.  \pacc showFunctionDeclarations(void), setShowFunctionDeclarations()
		Q_PROPERTY(bool showFunctionDeclarations READ showFunctionDeclarations WRITE setShowFunctionDeclarations)
		//! Enables or disables showing timestamps in the default message pattern. \pacc showTimestamp(void), setShowTimestamp()  \sa timestampFormat
		Q_PROPERTY(bool showTimestamp READ showTimestamp WRITE setShowTimestamp)
		//! Set the timestamp format, as per Qt message pattern docs for \c %{time ...} options. E.g. one of "process", "boot", or a \c QDateTime::toString() format. \pacc timestampFormat(void), setTimestampFormat() \sa showTimestamp
		Q_PROPERTY(QString timestampFormat READ timestampFormat WRITE setTimestampFormat)

	public:
		//! Get the singleton instance of this object. The instance is created automatically if necessary.
		static AppDebugMessageHandler *instance();
		//! This function must be called to initialize this custom message handler.  E.g. \c AppDebugMessageHandler::instance()->installAppMessageHandler()
		void installAppMessageHandler();

		inline quint8 appDebugOutputLevel() const { return m_appDebugOutputLevel; }  //!< \sa appDebugOutputLevel
		void setAppDebugOutputLevel(quint8 appDebugOutputLevel);  //!< \sa appDebugOutputLevel

		inline bool showSourcePath() const { return m_showSourcePath; }  //!< \sa showSourcePath
		void setShowSourcePath(bool showSourcePath);  //!< \sa showSourcePath
		//! Set the base path for source file name filter, everything after this is kept. The string could be literal or a RegEx pattern (evaluated as non-greedy).
		void setSourceBasePath(const QString &path = QString());

		inline bool showFunctionDeclarations() const { return m_showFunctionDeclarations; }  //!< \sa showFunctionDeclarations
		void setShowFunctionDeclarations(bool showFunctionDeclarations);  //!< \sa showFunctionDeclarations

		inline bool showTimestamp() const { return m_showTimestamp; }  //!< \sa showTimestamp
		void setShowTimestamp(bool showTimestamp);  //!< \sa showTimestamp

		inline QString timestampFormat() const { return m_tsFormat; }  //!< \sa timestampFormat
		void setTimestampFormat(const QString &timeFormat);  //!< \sa timestampFormat

		//! Add a new I/O stream for receiving messages.
		void addOutputDevice(QIODevice *device);
		//! Remove a previously-added I/O stream.
		void removeOutputDevice(QIODevice *device);

		//! Returns the current message pattern in use. This will be either the one set specifically with \c setMessagePattern() or the \c defaultMessagePattern() otherwise.
		QString messagePattern() const;
		//! Returns the default message pattern. This format will take into account any properties set previously, such as \c showSourcePath, \c showFunctionDeclarations, \c showTimestamp and \c timestampFormat.
		QString defaultMessagePattern() const;

		/*! Specifies a debug message pattern to use instead of the default.
			The \a pattern is the same as for \c qSetMessagePattern() but extended with the following attributes:

			\li \c %{short-type} : Short type name (eg. "W" for warning, "D" for debug, etc) (as returned by \c shortTypeNames())
			\li \c %{full-function} : Full function declaration including return and attribute types (if any)

			Call this function with a blank \c QString to reset the message pattern back to default.
		*/
		void setMessagePattern(const QString &pattern = QString());

		//! Handle a debug message. This is typically called by the installed global message handler callback ( \c g_appDebugMessageHandler() ).
		void messageHandler(QtMsgType type, const QMessageLogContext &context, const QString &msg);

		/*!
			Returns a reference to the mapping of \c QtMsgType enum values to abbreviated names.
			New names can be specified by setting this reference to a new value. For example:
			\code
				AppDebugMessageHandler::shortTypeNames() = {
					{QtDebugMsg,    QStringLiteral("DBG")},
					{QtWarningMsg,  QStringLiteral("WRN")},
					{QtCriticalMsg, QStringLiteral("CRT")},
					{QtFatalMsg,    QStringLiteral("FTL")},
					{QtInfoMsg,     QStringLiteral("INF")}
				};
			\endcode
		*/
		static QHash<int, QString> &shortTypeNames();

#if (QT_VERSION < QT_VERSION_CHECK(5, 4, 0))
		static QHash<int, QString> &fullTypeNames();
#endif

	signals:
		//! Notifies when a new log massage is available.
		void messageOutput(quint8 level, const QString &msg);

	private:
		explicit AppDebugMessageHandler();
		Q_DISABLE_COPY(AppDebugMessageHandler)

		QtMessageHandler m_defaultHandler;
		QRegularExpression m_srcPathFilter;
		quint8 m_appDebugOutputLevel;
		QVector<QIODevice *> m_outputDevices;
		bool m_showSourcePath;
		bool m_showFunctionDeclarations;
		bool m_showTimestamp;
		QString m_tsFormat;
		QString m_msgPattern;
		mutable QString m_defaultPattern;
		QReadWriteLock m_mutex;
#if (QT_VERSION < QT_VERSION_CHECK(5, 4, 0))
		QRegularExpression m_functionFilter;
#endif

};

//! \relates AppDebugMessageHandler
//! Message handler which is installed using qInstallMessageHandler. This needs to be global.
//! Use AppDebugMessageHandler::instance()->installAppMessageHandler();
//!  instead of installing this function directly (it will verify this handler is enabled, etc).
void g_appDebugMessageHandler(QtMsgType, const QMessageLogContext &, const QString &);

#endif // APPDEBUGMESSAGEHANDLER_H
